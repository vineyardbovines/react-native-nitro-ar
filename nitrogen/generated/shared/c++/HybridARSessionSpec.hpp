///
/// HybridARSessionSpec.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/HybridObject.hpp>)
#include <NitroModules/HybridObject.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `TrackingState` to properly resolve imports.
namespace margelo::nitro::ar { enum class TrackingState; }
// Forward declaration of `TrackingStateReason` to properly resolve imports.
namespace margelo::nitro::ar { enum class TrackingStateReason; }
// Forward declaration of `WorldMappingStatus` to properly resolve imports.
namespace margelo::nitro::ar { enum class WorldMappingStatus; }
// Forward declaration of `HybridARFrameSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARFrameSpec; }
// Forward declaration of `HybridARAnchorSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARAnchorSpec; }
// Forward declaration of `HybridARPlaneAnchorSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARPlaneAnchorSpec; }
// Forward declaration of `ARSessionConfiguration` to properly resolve imports.
namespace margelo::nitro::ar { struct ARSessionConfiguration; }
// Forward declaration of `CameraPose` to properly resolve imports.
namespace margelo::nitro::ar { struct CameraPose; }
// Forward declaration of `HybridARRaycastResultSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARRaycastResultSpec; }
// Forward declaration of `RaycastQuery` to properly resolve imports.
namespace margelo::nitro::ar { struct RaycastQuery; }
// Forward declaration of `HybridARMeasurementSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARMeasurementSpec; }
// Forward declaration of `HybridARWorldMapSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARWorldMapSpec; }

#include "TrackingState.hpp"
#include "TrackingStateReason.hpp"
#include "WorldMappingStatus.hpp"
#include <memory>
#include "HybridARFrameSpec.hpp"
#include <optional>
#include "HybridARAnchorSpec.hpp"
#include <vector>
#include "HybridARPlaneAnchorSpec.hpp"
#include "ARSessionConfiguration.hpp"
#include "CameraPose.hpp"
#include "HybridARRaycastResultSpec.hpp"
#include "RaycastQuery.hpp"
#include "HybridARMeasurementSpec.hpp"
#include "HybridARWorldMapSpec.hpp"
#include <NitroModules/Promise.hpp>
#include <functional>
#include <string>

namespace margelo::nitro::ar {

  using namespace margelo::nitro;

  /**
   * An abstract base class for `ARSession`
   * Inherit this class to create instances of `HybridARSessionSpec` in C++.
   * You must explicitly call `HybridObject`'s constructor yourself, because it is virtual.
   * @example
   * ```cpp
   * class HybridARSession: public HybridARSessionSpec {
   * public:
   *   HybridARSession(...): HybridObject(TAG) { ... }
   *   // ...
   * };
   * ```
   */
  class HybridARSessionSpec: public virtual HybridObject {
    public:
      // Constructor
      explicit HybridARSessionSpec(): HybridObject(TAG) { }

      // Destructor
      ~HybridARSessionSpec() override = default;

    public:
      // Properties
      virtual TrackingState getTrackingState() = 0;
      virtual TrackingStateReason getTrackingStateReason() = 0;
      virtual WorldMappingStatus getWorldMappingStatus() = 0;
      virtual bool getIsRunning() = 0;
      virtual std::optional<std::shared_ptr<HybridARFrameSpec>> getCurrentFrame() = 0;
      virtual std::vector<std::shared_ptr<HybridARAnchorSpec>> getAnchors() = 0;
      virtual std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>> getPlaneAnchors() = 0;

    public:
      // Methods
      virtual void start(const std::optional<ARSessionConfiguration>& config) = 0;
      virtual void pause() = 0;
      virtual void reset() = 0;
      virtual CameraPose getCameraPose() = 0;
      virtual std::optional<std::shared_ptr<HybridARRaycastResultSpec>> raycast(double x, double y) = 0;
      virtual std::vector<std::shared_ptr<HybridARRaycastResultSpec>> raycastWithQuery(const RaycastQuery& query) = 0;
      virtual std::shared_ptr<HybridARAnchorSpec> createAnchor(const std::shared_ptr<HybridARRaycastResultSpec>& hit) = 0;
      virtual std::shared_ptr<HybridARAnchorSpec> createAnchorAtPosition(const std::vector<double>& position, const std::optional<std::vector<double>>& rotation) = 0;
      virtual void removeAnchor(const std::shared_ptr<HybridARAnchorSpec>& anchor) = 0;
      virtual std::shared_ptr<HybridARMeasurementSpec> createMeasurement(const std::shared_ptr<HybridARAnchorSpec>& start, const std::shared_ptr<HybridARAnchorSpec>& end) = 0;
      virtual std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>> getCurrentWorldMap() = 0;
      virtual std::function<void()> onFrameUpdate(const std::function<void(const std::shared_ptr<HybridARFrameSpec>& /* frame */)>& callback) = 0;
      virtual std::function<void()> onTrackingStateChanged(const std::function<void(TrackingState /* state */, TrackingStateReason /* reason */)>& callback) = 0;
      virtual std::function<void()> onAnchorsUpdated(const std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>& callback) = 0;
      virtual std::function<void()> onPlanesUpdated(const std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>& callback) = 0;

    protected:
      // Hybrid Setup
      void loadHybridMethods() override;

    protected:
      // Tag for logging
      static constexpr auto TAG = "ARSession";
  };

} // namespace margelo::nitro::ar
