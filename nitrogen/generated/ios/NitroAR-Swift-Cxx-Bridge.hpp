///
/// NitroAR-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `ARObjectMeasurement` to properly resolve imports.
namespace margelo::nitro::ar { struct ARObjectMeasurement; }
// Forward declaration of `ARSessionConfiguration` to properly resolve imports.
namespace margelo::nitro::ar { struct ARSessionConfiguration; }
// Forward declaration of `ARViewHitResult` to properly resolve imports.
namespace margelo::nitro::ar { struct ARViewHitResult; }
// Forward declaration of `CameraPose` to properly resolve imports.
namespace margelo::nitro::ar { struct CameraPose; }
// Forward declaration of `EnvironmentTexturing` to properly resolve imports.
namespace margelo::nitro::ar { enum class EnvironmentTexturing; }
// Forward declaration of `HybridARAnchorSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARAnchorSpec; }
// Forward declaration of `HybridARBoundingBoxBuilderSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARBoundingBoxBuilderSpec; }
// Forward declaration of `HybridARDepthDataSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARDepthDataSpec; }
// Forward declaration of `HybridARDirectionalLightEstimateSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARDirectionalLightEstimateSpec; }
// Forward declaration of `HybridARFrameSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARFrameSpec; }
// Forward declaration of `HybridARLightEstimateSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARLightEstimateSpec; }
// Forward declaration of `HybridARMeasurementSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARMeasurementSpec; }
// Forward declaration of `HybridARMeshAnchorSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARMeshAnchorSpec; }
// Forward declaration of `HybridARPlaneAnchorSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARPlaneAnchorSpec; }
// Forward declaration of `HybridARPlaneGeometrySpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARPlaneGeometrySpec; }
// Forward declaration of `HybridARRaycastResultSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARRaycastResultSpec; }
// Forward declaration of `HybridARSegmentationResultSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARSegmentationResultSpec; }
// Forward declaration of `HybridARSessionSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARSessionSpec; }
// Forward declaration of `HybridARViewSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARViewSpec; }
// Forward declaration of `HybridARVolumeSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARVolumeSpec; }
// Forward declaration of `HybridARWorldMapSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARWorldMapSpec; }
// Forward declaration of `LiDARCapabilities` to properly resolve imports.
namespace margelo::nitro::ar { struct LiDARCapabilities; }
// Forward declaration of `MeshClassification` to properly resolve imports.
namespace margelo::nitro::ar { enum class MeshClassification; }
// Forward declaration of `PlaneDetectionMode` to properly resolve imports.
namespace margelo::nitro::ar { enum class PlaneDetectionMode; }
// Forward declaration of `SceneReconstructionMode` to properly resolve imports.
namespace margelo::nitro::ar { enum class SceneReconstructionMode; }
// Forward declaration of `TrackingStateReason` to properly resolve imports.
namespace margelo::nitro::ar { enum class TrackingStateReason; }
// Forward declaration of `TrackingState` to properly resolve imports.
namespace margelo::nitro::ar { enum class TrackingState; }
// Forward declaration of `WorldAlignment` to properly resolve imports.
namespace margelo::nitro::ar { enum class WorldAlignment; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridARAnchorSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARAnchorSpec_cxx; }
// Forward declaration of `HybridARBoundingBoxBuilderSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARBoundingBoxBuilderSpec_cxx; }
// Forward declaration of `HybridARDepthDataSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARDepthDataSpec_cxx; }
// Forward declaration of `HybridARDirectionalLightEstimateSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARDirectionalLightEstimateSpec_cxx; }
// Forward declaration of `HybridARFrameSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARFrameSpec_cxx; }
// Forward declaration of `HybridARLightEstimateSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARLightEstimateSpec_cxx; }
// Forward declaration of `HybridARMeasurementSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARMeasurementSpec_cxx; }
// Forward declaration of `HybridARMeshAnchorSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARMeshAnchorSpec_cxx; }
// Forward declaration of `HybridARPlaneAnchorSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARPlaneAnchorSpec_cxx; }
// Forward declaration of `HybridARPlaneGeometrySpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARPlaneGeometrySpec_cxx; }
// Forward declaration of `HybridARRaycastResultSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARRaycastResultSpec_cxx; }
// Forward declaration of `HybridARSegmentationResultSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARSegmentationResultSpec_cxx; }
// Forward declaration of `HybridARSessionSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARSessionSpec_cxx; }
// Forward declaration of `HybridARViewSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARViewSpec_cxx; }
// Forward declaration of `HybridARVolumeSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARVolumeSpec_cxx; }
// Forward declaration of `HybridARWorldMapSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARWorldMapSpec_cxx; }

// Include C++ defined types
#include "ARObjectMeasurement.hpp"
#include "ARSessionConfiguration.hpp"
#include "ARViewHitResult.hpp"
#include "CameraPose.hpp"
#include "EnvironmentTexturing.hpp"
#include "HybridARAnchorSpec.hpp"
#include "HybridARBoundingBoxBuilderSpec.hpp"
#include "HybridARDepthDataSpec.hpp"
#include "HybridARDirectionalLightEstimateSpec.hpp"
#include "HybridARFrameSpec.hpp"
#include "HybridARLightEstimateSpec.hpp"
#include "HybridARMeasurementSpec.hpp"
#include "HybridARMeshAnchorSpec.hpp"
#include "HybridARPlaneAnchorSpec.hpp"
#include "HybridARPlaneGeometrySpec.hpp"
#include "HybridARRaycastResultSpec.hpp"
#include "HybridARSegmentationResultSpec.hpp"
#include "HybridARSessionSpec.hpp"
#include "HybridARViewSpec.hpp"
#include "HybridARVolumeSpec.hpp"
#include "HybridARWorldMapSpec.hpp"
#include "LiDARCapabilities.hpp"
#include "MeshClassification.hpp"
#include "PlaneDetectionMode.hpp"
#include "SceneReconstructionMode.hpp"
#include "TrackingState.hpp"
#include "TrackingStateReason.hpp"
#include "WorldAlignment.hpp"
#include <NitroModules/Promise.hpp>
#include <NitroModules/PromiseHolder.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::ar::bridge::swift {

  // pragma MARK: std::vector<double>
  /**
   * Specialized version of `std::vector<double>`.
   */
  using std__vector_double_ = std::vector<double>;
  inline std::vector<double> create_std__vector_double_(size_t size) noexcept {
    std::vector<double> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridARAnchorSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARAnchorSpec>`.
   */
  using std__shared_ptr_HybridARAnchorSpec_ = std::shared_ptr<HybridARAnchorSpec>;
  std::shared_ptr<HybridARAnchorSpec> create_std__shared_ptr_HybridARAnchorSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARAnchorSpec_(std__shared_ptr_HybridARAnchorSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARAnchorSpec>
  using std__weak_ptr_HybridARAnchorSpec_ = std::weak_ptr<HybridARAnchorSpec>;
  inline std__weak_ptr_HybridARAnchorSpec_ weakify_std__shared_ptr_HybridARAnchorSpec_(const std::shared_ptr<HybridARAnchorSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<HybridARVolumeSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARVolumeSpec>`.
   */
  using std__shared_ptr_HybridARVolumeSpec_ = std::shared_ptr<HybridARVolumeSpec>;
  std::shared_ptr<HybridARVolumeSpec> create_std__shared_ptr_HybridARVolumeSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARVolumeSpec_(std__shared_ptr_HybridARVolumeSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARVolumeSpec>
  using std__weak_ptr_HybridARVolumeSpec_ = std::weak_ptr<HybridARVolumeSpec>;
  inline std__weak_ptr_HybridARVolumeSpec_ weakify_std__shared_ptr_HybridARVolumeSpec_(const std::shared_ptr<HybridARVolumeSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<HybridARBoundingBoxBuilderSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARBoundingBoxBuilderSpec>`.
   */
  using std__shared_ptr_HybridARBoundingBoxBuilderSpec_ = std::shared_ptr<HybridARBoundingBoxBuilderSpec>;
  std::shared_ptr<HybridARBoundingBoxBuilderSpec> create_std__shared_ptr_HybridARBoundingBoxBuilderSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARBoundingBoxBuilderSpec_(std__shared_ptr_HybridARBoundingBoxBuilderSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARBoundingBoxBuilderSpec>
  using std__weak_ptr_HybridARBoundingBoxBuilderSpec_ = std::weak_ptr<HybridARBoundingBoxBuilderSpec>;
  inline std__weak_ptr_HybridARBoundingBoxBuilderSpec_ weakify_std__shared_ptr_HybridARBoundingBoxBuilderSpec_(const std::shared_ptr<HybridARBoundingBoxBuilderSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<HybridARVolumeSpec>>
  using Result_std__shared_ptr_HybridARVolumeSpec__ = Result<std::shared_ptr<HybridARVolumeSpec>>;
  inline Result_std__shared_ptr_HybridARVolumeSpec__ create_Result_std__shared_ptr_HybridARVolumeSpec__(const std::shared_ptr<HybridARVolumeSpec>& value) noexcept {
    return Result<std::shared_ptr<HybridARVolumeSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_HybridARVolumeSpec__ create_Result_std__shared_ptr_HybridARVolumeSpec__(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<HybridARVolumeSpec>>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridARDepthDataSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARDepthDataSpec>`.
   */
  using std__shared_ptr_HybridARDepthDataSpec_ = std::shared_ptr<HybridARDepthDataSpec>;
  std::shared_ptr<HybridARDepthDataSpec> create_std__shared_ptr_HybridARDepthDataSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARDepthDataSpec_(std__shared_ptr_HybridARDepthDataSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARDepthDataSpec>
  using std__weak_ptr_HybridARDepthDataSpec_ = std::weak_ptr<HybridARDepthDataSpec>;
  inline std__weak_ptr_HybridARDepthDataSpec_ weakify_std__shared_ptr_HybridARDepthDataSpec_(const std::shared_ptr<HybridARDepthDataSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<double>
  using Result_double_ = Result<double>;
  inline Result_double_ create_Result_double_(double value) noexcept {
    return Result<double>::withValue(std::move(value));
  }
  inline Result_double_ create_Result_double_(const std::exception_ptr& error) noexcept {
    return Result<double>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridARLightEstimateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARLightEstimateSpec>`.
   */
  using std__shared_ptr_HybridARLightEstimateSpec_ = std::shared_ptr<HybridARLightEstimateSpec>;
  std::shared_ptr<HybridARLightEstimateSpec> create_std__shared_ptr_HybridARLightEstimateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARLightEstimateSpec_(std__shared_ptr_HybridARLightEstimateSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARLightEstimateSpec>
  using std__weak_ptr_HybridARLightEstimateSpec_ = std::weak_ptr<HybridARLightEstimateSpec>;
  inline std__weak_ptr_HybridARLightEstimateSpec_ weakify_std__shared_ptr_HybridARLightEstimateSpec_(const std::shared_ptr<HybridARLightEstimateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridARLightEstimateSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridARLightEstimateSpec>>`.
   */
  using std__optional_std__shared_ptr_HybridARLightEstimateSpec__ = std::optional<std::shared_ptr<HybridARLightEstimateSpec>>;
  inline std::optional<std::shared_ptr<HybridARLightEstimateSpec>> create_std__optional_std__shared_ptr_HybridARLightEstimateSpec__(const std::shared_ptr<HybridARLightEstimateSpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridARLightEstimateSpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridARLightEstimateSpec__(const std::optional<std::shared_ptr<HybridARLightEstimateSpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridARLightEstimateSpec> get_std__optional_std__shared_ptr_HybridARLightEstimateSpec__(const std::optional<std::shared_ptr<HybridARLightEstimateSpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridARDirectionalLightEstimateSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARDirectionalLightEstimateSpec>`.
   */
  using std__shared_ptr_HybridARDirectionalLightEstimateSpec_ = std::shared_ptr<HybridARDirectionalLightEstimateSpec>;
  std::shared_ptr<HybridARDirectionalLightEstimateSpec> create_std__shared_ptr_HybridARDirectionalLightEstimateSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARDirectionalLightEstimateSpec_(std__shared_ptr_HybridARDirectionalLightEstimateSpec_ cppType);
  
  // pragma MARK: std::shared_ptr<HybridARLightEstimateSpec>
  inline std::shared_ptr<HybridARLightEstimateSpec> upcast_ARDirectionalLightEstimate_to_ARLightEstimate(std::shared_ptr<HybridARDirectionalLightEstimateSpec> child) noexcept { return child; }
  
  // pragma MARK: std::weak_ptr<HybridARDirectionalLightEstimateSpec>
  using std__weak_ptr_HybridARDirectionalLightEstimateSpec_ = std::weak_ptr<HybridARDirectionalLightEstimateSpec>;
  inline std__weak_ptr_HybridARDirectionalLightEstimateSpec_ weakify_std__shared_ptr_HybridARDirectionalLightEstimateSpec_(const std::shared_ptr<HybridARDirectionalLightEstimateSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>>`.
   */
  using std__optional_std__shared_ptr_HybridARDirectionalLightEstimateSpec__ = std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>>;
  inline std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>> create_std__optional_std__shared_ptr_HybridARDirectionalLightEstimateSpec__(const std::shared_ptr<HybridARDirectionalLightEstimateSpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridARDirectionalLightEstimateSpec__(const std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridARDirectionalLightEstimateSpec> get_std__optional_std__shared_ptr_HybridARDirectionalLightEstimateSpec__(const std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridARDepthDataSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridARDepthDataSpec>>`.
   */
  using std__optional_std__shared_ptr_HybridARDepthDataSpec__ = std::optional<std::shared_ptr<HybridARDepthDataSpec>>;
  inline std::optional<std::shared_ptr<HybridARDepthDataSpec>> create_std__optional_std__shared_ptr_HybridARDepthDataSpec__(const std::shared_ptr<HybridARDepthDataSpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridARDepthDataSpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridARDepthDataSpec__(const std::optional<std::shared_ptr<HybridARDepthDataSpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridARDepthDataSpec> get_std__optional_std__shared_ptr_HybridARDepthDataSpec__(const std::optional<std::shared_ptr<HybridARDepthDataSpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridARFrameSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARFrameSpec>`.
   */
  using std__shared_ptr_HybridARFrameSpec_ = std::shared_ptr<HybridARFrameSpec>;
  std::shared_ptr<HybridARFrameSpec> create_std__shared_ptr_HybridARFrameSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARFrameSpec_(std__shared_ptr_HybridARFrameSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARFrameSpec>
  using std__weak_ptr_HybridARFrameSpec_ = std::weak_ptr<HybridARFrameSpec>;
  inline std__weak_ptr_HybridARFrameSpec_ weakify_std__shared_ptr_HybridARFrameSpec_(const std::shared_ptr<HybridARFrameSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::string>
  using Result_std__string_ = Result<std::string>;
  inline Result_std__string_ create_Result_std__string_(const std::string& value) noexcept {
    return Result<std::string>::withValue(value);
  }
  inline Result_std__string_ create_Result_std__string_(const std::exception_ptr& error) noexcept {
    return Result<std::string>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridARMeasurementSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARMeasurementSpec>`.
   */
  using std__shared_ptr_HybridARMeasurementSpec_ = std::shared_ptr<HybridARMeasurementSpec>;
  std::shared_ptr<HybridARMeasurementSpec> create_std__shared_ptr_HybridARMeasurementSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARMeasurementSpec_(std__shared_ptr_HybridARMeasurementSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARMeasurementSpec>
  using std__weak_ptr_HybridARMeasurementSpec_ = std::weak_ptr<HybridARMeasurementSpec>;
  inline std__weak_ptr_HybridARMeasurementSpec_ weakify_std__shared_ptr_HybridARMeasurementSpec_(const std::shared_ptr<HybridARMeasurementSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::optional<ARObjectMeasurement>
  /**
   * Specialized version of `std::optional<ARObjectMeasurement>`.
   */
  using std__optional_ARObjectMeasurement_ = std::optional<ARObjectMeasurement>;
  inline std::optional<ARObjectMeasurement> create_std__optional_ARObjectMeasurement_(const ARObjectMeasurement& value) noexcept {
    return std::optional<ARObjectMeasurement>(value);
  }
  inline bool has_value_std__optional_ARObjectMeasurement_(const std::optional<ARObjectMeasurement>& optional) noexcept {
    return optional.has_value();
  }
  inline ARObjectMeasurement get_std__optional_ARObjectMeasurement_(const std::optional<ARObjectMeasurement>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<HybridARSegmentationResultSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARSegmentationResultSpec>`.
   */
  using std__shared_ptr_HybridARSegmentationResultSpec_ = std::shared_ptr<HybridARSegmentationResultSpec>;
  std::shared_ptr<HybridARSegmentationResultSpec> create_std__shared_ptr_HybridARSegmentationResultSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARSegmentationResultSpec_(std__shared_ptr_HybridARSegmentationResultSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARSegmentationResultSpec>
  using std__weak_ptr_HybridARSegmentationResultSpec_ = std::weak_ptr<HybridARSegmentationResultSpec>;
  inline std__weak_ptr_HybridARSegmentationResultSpec_ weakify_std__shared_ptr_HybridARSegmentationResultSpec_(const std::shared_ptr<HybridARSegmentationResultSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::vector<double>>
  using Result_std__vector_double__ = Result<std::vector<double>>;
  inline Result_std__vector_double__ create_Result_std__vector_double__(const std::vector<double>& value) noexcept {
    return Result<std::vector<double>>::withValue(value);
  }
  inline Result_std__vector_double__ create_Result_std__vector_double__(const std::exception_ptr& error) noexcept {
    return Result<std::vector<double>>::withError(error);
  }
  
  // pragma MARK: Result<std::optional<ARObjectMeasurement>>
  using Result_std__optional_ARObjectMeasurement__ = Result<std::optional<ARObjectMeasurement>>;
  inline Result_std__optional_ARObjectMeasurement__ create_Result_std__optional_ARObjectMeasurement__(const std::optional<ARObjectMeasurement>& value) noexcept {
    return Result<std::optional<ARObjectMeasurement>>::withValue(value);
  }
  inline Result_std__optional_ARObjectMeasurement__ create_Result_std__optional_ARObjectMeasurement__(const std::exception_ptr& error) noexcept {
    return Result<std::optional<ARObjectMeasurement>>::withError(error);
  }
  
  // pragma MARK: std::shared_ptr<HybridARPlaneGeometrySpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARPlaneGeometrySpec>`.
   */
  using std__shared_ptr_HybridARPlaneGeometrySpec_ = std::shared_ptr<HybridARPlaneGeometrySpec>;
  std::shared_ptr<HybridARPlaneGeometrySpec> create_std__shared_ptr_HybridARPlaneGeometrySpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARPlaneGeometrySpec_(std__shared_ptr_HybridARPlaneGeometrySpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARPlaneGeometrySpec>
  using std__weak_ptr_HybridARPlaneGeometrySpec_ = std::weak_ptr<HybridARPlaneGeometrySpec>;
  inline std__weak_ptr_HybridARPlaneGeometrySpec_ weakify_std__shared_ptr_HybridARPlaneGeometrySpec_(const std::shared_ptr<HybridARPlaneGeometrySpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<HybridARPlaneAnchorSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARPlaneAnchorSpec>`.
   */
  using std__shared_ptr_HybridARPlaneAnchorSpec_ = std::shared_ptr<HybridARPlaneAnchorSpec>;
  std::shared_ptr<HybridARPlaneAnchorSpec> create_std__shared_ptr_HybridARPlaneAnchorSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARPlaneAnchorSpec_(std__shared_ptr_HybridARPlaneAnchorSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARPlaneAnchorSpec>
  using std__weak_ptr_HybridARPlaneAnchorSpec_ = std::weak_ptr<HybridARPlaneAnchorSpec>;
  inline std__weak_ptr_HybridARPlaneAnchorSpec_ weakify_std__shared_ptr_HybridARPlaneAnchorSpec_(const std::shared_ptr<HybridARPlaneAnchorSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<HybridARRaycastResultSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARRaycastResultSpec>`.
   */
  using std__shared_ptr_HybridARRaycastResultSpec_ = std::shared_ptr<HybridARRaycastResultSpec>;
  std::shared_ptr<HybridARRaycastResultSpec> create_std__shared_ptr_HybridARRaycastResultSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARRaycastResultSpec_(std__shared_ptr_HybridARRaycastResultSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARRaycastResultSpec>
  using std__weak_ptr_HybridARRaycastResultSpec_ = std::weak_ptr<HybridARRaycastResultSpec>;
  inline std__weak_ptr_HybridARRaycastResultSpec_ weakify_std__shared_ptr_HybridARRaycastResultSpec_(const std::shared_ptr<HybridARRaycastResultSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::vector<MeshClassification>
  /**
   * Specialized version of `std::vector<MeshClassification>`.
   */
  using std__vector_MeshClassification_ = std::vector<MeshClassification>;
  inline std::vector<MeshClassification> create_std__vector_MeshClassification_(size_t size) noexcept {
    std::vector<MeshClassification> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<HybridARMeshAnchorSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARMeshAnchorSpec>`.
   */
  using std__shared_ptr_HybridARMeshAnchorSpec_ = std::shared_ptr<HybridARMeshAnchorSpec>;
  std::shared_ptr<HybridARMeshAnchorSpec> create_std__shared_ptr_HybridARMeshAnchorSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARMeshAnchorSpec_(std__shared_ptr_HybridARMeshAnchorSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARMeshAnchorSpec>
  using std__weak_ptr_HybridARMeshAnchorSpec_ = std::weak_ptr<HybridARMeshAnchorSpec>;
  inline std__weak_ptr_HybridARMeshAnchorSpec_ weakify_std__shared_ptr_HybridARMeshAnchorSpec_(const std::shared_ptr<HybridARMeshAnchorSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::vector<PlaneDetectionMode>
  /**
   * Specialized version of `std::vector<PlaneDetectionMode>`.
   */
  using std__vector_PlaneDetectionMode_ = std::vector<PlaneDetectionMode>;
  inline std::vector<PlaneDetectionMode> create_std__vector_PlaneDetectionMode_(size_t size) noexcept {
    std::vector<PlaneDetectionMode> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<PlaneDetectionMode>>
  /**
   * Specialized version of `std::optional<std::vector<PlaneDetectionMode>>`.
   */
  using std__optional_std__vector_PlaneDetectionMode__ = std::optional<std::vector<PlaneDetectionMode>>;
  inline std::optional<std::vector<PlaneDetectionMode>> create_std__optional_std__vector_PlaneDetectionMode__(const std::vector<PlaneDetectionMode>& value) noexcept {
    return std::optional<std::vector<PlaneDetectionMode>>(value);
  }
  inline bool has_value_std__optional_std__vector_PlaneDetectionMode__(const std::optional<std::vector<PlaneDetectionMode>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<PlaneDetectionMode> get_std__optional_std__vector_PlaneDetectionMode__(const std::optional<std::vector<PlaneDetectionMode>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<bool>
  /**
   * Specialized version of `std::optional<bool>`.
   */
  using std__optional_bool_ = std::optional<bool>;
  inline std::optional<bool> create_std__optional_bool_(const bool& value) noexcept {
    return std::optional<bool>(value);
  }
  inline bool has_value_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return optional.has_value();
  }
  inline bool get_std__optional_bool_(const std::optional<bool>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<EnvironmentTexturing>
  /**
   * Specialized version of `std::optional<EnvironmentTexturing>`.
   */
  using std__optional_EnvironmentTexturing_ = std::optional<EnvironmentTexturing>;
  inline std::optional<EnvironmentTexturing> create_std__optional_EnvironmentTexturing_(const EnvironmentTexturing& value) noexcept {
    return std::optional<EnvironmentTexturing>(value);
  }
  inline bool has_value_std__optional_EnvironmentTexturing_(const std::optional<EnvironmentTexturing>& optional) noexcept {
    return optional.has_value();
  }
  inline EnvironmentTexturing get_std__optional_EnvironmentTexturing_(const std::optional<EnvironmentTexturing>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<WorldAlignment>
  /**
   * Specialized version of `std::optional<WorldAlignment>`.
   */
  using std__optional_WorldAlignment_ = std::optional<WorldAlignment>;
  inline std::optional<WorldAlignment> create_std__optional_WorldAlignment_(const WorldAlignment& value) noexcept {
    return std::optional<WorldAlignment>(value);
  }
  inline bool has_value_std__optional_WorldAlignment_(const std::optional<WorldAlignment>& optional) noexcept {
    return optional.has_value();
  }
  inline WorldAlignment get_std__optional_WorldAlignment_(const std::optional<WorldAlignment>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<SceneReconstructionMode>
  /**
   * Specialized version of `std::optional<SceneReconstructionMode>`.
   */
  using std__optional_SceneReconstructionMode_ = std::optional<SceneReconstructionMode>;
  inline std::optional<SceneReconstructionMode> create_std__optional_SceneReconstructionMode_(const SceneReconstructionMode& value) noexcept {
    return std::optional<SceneReconstructionMode>(value);
  }
  inline bool has_value_std__optional_SceneReconstructionMode_(const std::optional<SceneReconstructionMode>& optional) noexcept {
    return optional.has_value();
  }
  inline SceneReconstructionMode get_std__optional_SceneReconstructionMode_(const std::optional<SceneReconstructionMode>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<ARSessionConfiguration>
  /**
   * Specialized version of `std::optional<ARSessionConfiguration>`.
   */
  using std__optional_ARSessionConfiguration_ = std::optional<ARSessionConfiguration>;
  inline std::optional<ARSessionConfiguration> create_std__optional_ARSessionConfiguration_(const ARSessionConfiguration& value) noexcept {
    return std::optional<ARSessionConfiguration>(value);
  }
  inline bool has_value_std__optional_ARSessionConfiguration_(const std::optional<ARSessionConfiguration>& optional) noexcept {
    return optional.has_value();
  }
  inline ARSessionConfiguration get_std__optional_ARSessionConfiguration_(const std::optional<ARSessionConfiguration>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridARFrameSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridARFrameSpec>>`.
   */
  using std__optional_std__shared_ptr_HybridARFrameSpec__ = std::optional<std::shared_ptr<HybridARFrameSpec>>;
  inline std::optional<std::shared_ptr<HybridARFrameSpec>> create_std__optional_std__shared_ptr_HybridARFrameSpec__(const std::shared_ptr<HybridARFrameSpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridARFrameSpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridARFrameSpec__(const std::optional<std::shared_ptr<HybridARFrameSpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridARFrameSpec> get_std__optional_std__shared_ptr_HybridARFrameSpec__(const std::optional<std::shared_ptr<HybridARFrameSpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridARRaycastResultSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridARRaycastResultSpec>>`.
   */
  using std__optional_std__shared_ptr_HybridARRaycastResultSpec__ = std::optional<std::shared_ptr<HybridARRaycastResultSpec>>;
  inline std::optional<std::shared_ptr<HybridARRaycastResultSpec>> create_std__optional_std__shared_ptr_HybridARRaycastResultSpec__(const std::shared_ptr<HybridARRaycastResultSpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridARRaycastResultSpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridARRaycastResultSpec__(const std::optional<std::shared_ptr<HybridARRaycastResultSpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridARRaycastResultSpec> get_std__optional_std__shared_ptr_HybridARRaycastResultSpec__(const std::optional<std::shared_ptr<HybridARRaycastResultSpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::shared_ptr<HybridARRaycastResultSpec>>
  /**
   * Specialized version of `std::vector<std::shared_ptr<HybridARRaycastResultSpec>>`.
   */
  using std__vector_std__shared_ptr_HybridARRaycastResultSpec__ = std::vector<std::shared_ptr<HybridARRaycastResultSpec>>;
  inline std::vector<std::shared_ptr<HybridARRaycastResultSpec>> create_std__vector_std__shared_ptr_HybridARRaycastResultSpec__(size_t size) noexcept {
    std::vector<std::shared_ptr<HybridARRaycastResultSpec>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::optional<std::vector<double>>
  /**
   * Specialized version of `std::optional<std::vector<double>>`.
   */
  using std__optional_std__vector_double__ = std::optional<std::vector<double>>;
  inline std::optional<std::vector<double>> create_std__optional_std__vector_double__(const std::vector<double>& value) noexcept {
    return std::optional<std::vector<double>>(value);
  }
  inline bool has_value_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<double> get_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::vector<std::shared_ptr<HybridARAnchorSpec>>
  /**
   * Specialized version of `std::vector<std::shared_ptr<HybridARAnchorSpec>>`.
   */
  using std__vector_std__shared_ptr_HybridARAnchorSpec__ = std::vector<std::shared_ptr<HybridARAnchorSpec>>;
  inline std::vector<std::shared_ptr<HybridARAnchorSpec>> create_std__vector_std__shared_ptr_HybridARAnchorSpec__(size_t size) noexcept {
    std::vector<std::shared_ptr<HybridARAnchorSpec>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>
  /**
   * Specialized version of `std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>`.
   */
  using std__vector_std__shared_ptr_HybridARPlaneAnchorSpec__ = std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>;
  inline std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>> create_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec__(size_t size) noexcept {
    std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::shared_ptr<HybridARWorldMapSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARWorldMapSpec>`.
   */
  using std__shared_ptr_HybridARWorldMapSpec_ = std::shared_ptr<HybridARWorldMapSpec>;
  std::shared_ptr<HybridARWorldMapSpec> create_std__shared_ptr_HybridARWorldMapSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARWorldMapSpec_(std__shared_ptr_HybridARWorldMapSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARWorldMapSpec>
  using std__weak_ptr_HybridARWorldMapSpec_ = std::weak_ptr<HybridARWorldMapSpec>;
  inline std__weak_ptr_HybridARWorldMapSpec_ weakify_std__shared_ptr_HybridARWorldMapSpec_(const std::shared_ptr<HybridARWorldMapSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>`.
   */
  using std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec___ = std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>;
  inline std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>> create_std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec___() noexcept {
    return Promise<std::shared_ptr<HybridARWorldMapSpec>>::create();
  }
  inline PromiseHolder<std::shared_ptr<HybridARWorldMapSpec>> wrap_std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec___(std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>> promise) noexcept {
    return PromiseHolder<std::shared_ptr<HybridARWorldMapSpec>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::shared_ptr<HybridARWorldMapSpec>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::shared_ptr<HybridARWorldMapSpec>&)>`.
   */
  using Func_void_std__shared_ptr_HybridARWorldMapSpec_ = std::function<void(const std::shared_ptr<HybridARWorldMapSpec>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::shared_ptr<HybridARWorldMapSpec>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__shared_ptr_HybridARWorldMapSpec__Wrapper final {
  public:
    explicit Func_void_std__shared_ptr_HybridARWorldMapSpec__Wrapper(std::function<void(const std::shared_ptr<HybridARWorldMapSpec>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::shared_ptr<HybridARWorldMapSpec>& /* result */)>>(std::move(func))) {}
    inline void call(std::shared_ptr<HybridARWorldMapSpec> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::shared_ptr<HybridARWorldMapSpec>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__shared_ptr_HybridARWorldMapSpec_ create_Func_void_std__shared_ptr_HybridARWorldMapSpec_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__shared_ptr_HybridARWorldMapSpec__Wrapper wrap_Func_void_std__shared_ptr_HybridARWorldMapSpec_(Func_void_std__shared_ptr_HybridARWorldMapSpec_ value) noexcept {
    return Func_void_std__shared_ptr_HybridARWorldMapSpec__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  /**
   * Specialized version of `std::function<void(const std::exception_ptr&)>`.
   */
  using Func_void_std__exception_ptr = std::function<void(const std::exception_ptr& /* error */)>;
  /**
   * Wrapper class for a `std::function<void(const std::exception_ptr& / * error * /)>`, this can be used from Swift.
   */
  class Func_void_std__exception_ptr_Wrapper final {
  public:
    explicit Func_void_std__exception_ptr_Wrapper(std::function<void(const std::exception_ptr& /* error */)>&& func): _function(std::make_unique<std::function<void(const std::exception_ptr& /* error */)>>(std::move(func))) {}
    inline void call(std::exception_ptr error) const noexcept {
      _function->operator()(error);
    }
  private:
    std::unique_ptr<std::function<void(const std::exception_ptr& /* error */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__exception_ptr_Wrapper wrap_Func_void_std__exception_ptr(Func_void_std__exception_ptr value) noexcept {
    return Func_void_std__exception_ptr_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::shared_ptr<HybridARFrameSpec>& /* frame */)>
  /**
   * Specialized version of `std::function<void(const std::shared_ptr<HybridARFrameSpec>&)>`.
   */
  using Func_void_std__shared_ptr_HybridARFrameSpec_ = std::function<void(const std::shared_ptr<HybridARFrameSpec>& /* frame */)>;
  /**
   * Wrapper class for a `std::function<void(const std::shared_ptr<HybridARFrameSpec>& / * frame * /)>`, this can be used from Swift.
   */
  class Func_void_std__shared_ptr_HybridARFrameSpec__Wrapper final {
  public:
    explicit Func_void_std__shared_ptr_HybridARFrameSpec__Wrapper(std::function<void(const std::shared_ptr<HybridARFrameSpec>& /* frame */)>&& func): _function(std::make_unique<std::function<void(const std::shared_ptr<HybridARFrameSpec>& /* frame */)>>(std::move(func))) {}
    inline void call(std::shared_ptr<HybridARFrameSpec> frame) const noexcept {
      _function->operator()(frame);
    }
  private:
    std::unique_ptr<std::function<void(const std::shared_ptr<HybridARFrameSpec>& /* frame */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__shared_ptr_HybridARFrameSpec_ create_Func_void_std__shared_ptr_HybridARFrameSpec_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__shared_ptr_HybridARFrameSpec__Wrapper wrap_Func_void_std__shared_ptr_HybridARFrameSpec_(Func_void_std__shared_ptr_HybridARFrameSpec_ value) noexcept {
    return Func_void_std__shared_ptr_HybridARFrameSpec__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(TrackingState /* state */, TrackingStateReason /* reason */)>
  /**
   * Specialized version of `std::function<void(TrackingState, TrackingStateReason)>`.
   */
  using Func_void_TrackingState_TrackingStateReason = std::function<void(TrackingState /* state */, TrackingStateReason /* reason */)>;
  /**
   * Wrapper class for a `std::function<void(TrackingState / * state * /, TrackingStateReason / * reason * /)>`, this can be used from Swift.
   */
  class Func_void_TrackingState_TrackingStateReason_Wrapper final {
  public:
    explicit Func_void_TrackingState_TrackingStateReason_Wrapper(std::function<void(TrackingState /* state */, TrackingStateReason /* reason */)>&& func): _function(std::make_unique<std::function<void(TrackingState /* state */, TrackingStateReason /* reason */)>>(std::move(func))) {}
    inline void call(int state, int reason) const noexcept {
      _function->operator()(static_cast<TrackingState>(state), static_cast<TrackingStateReason>(reason));
    }
  private:
    std::unique_ptr<std::function<void(TrackingState /* state */, TrackingStateReason /* reason */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_TrackingState_TrackingStateReason create_Func_void_TrackingState_TrackingStateReason(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_TrackingState_TrackingStateReason_Wrapper wrap_Func_void_TrackingState_TrackingStateReason(Func_void_TrackingState_TrackingStateReason value) noexcept {
    return Func_void_TrackingState_TrackingStateReason_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<std::string>
  /**
   * Specialized version of `std::vector<std::string>`.
   */
  using std__vector_std__string_ = std::vector<std::string>;
  inline std::vector<std::string> create_std__vector_std__string_(size_t size) noexcept {
    std::vector<std::string> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>
  /**
   * Specialized version of `std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>&, const std::vector<std::shared_ptr<HybridARAnchorSpec>>&, const std::vector<std::string>&)>`.
   */
  using Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_ = std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& / * added * /, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& / * updated * /, const std::vector<std::string>& / * removed * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string__Wrapper final {
  public:
    explicit Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string__Wrapper(std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>&& func): _function(std::make_unique<std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>>(std::move(func))) {}
    inline void call(std::vector<std::shared_ptr<HybridARAnchorSpec>> added, std::vector<std::shared_ptr<HybridARAnchorSpec>> updated, std::vector<std::string> removed) const noexcept {
      _function->operator()(added, updated, removed);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_ create_Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string__Wrapper wrap_Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_(Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_ value) noexcept {
    return Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>
  /**
   * Specialized version of `std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>&, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>&, const std::vector<std::string>&)>`.
   */
  using Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_ = std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& / * added * /, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& / * updated * /, const std::vector<std::string>& / * removed * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string__Wrapper final {
  public:
    explicit Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string__Wrapper(std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>&& func): _function(std::make_unique<std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>>(std::move(func))) {}
    inline void call(std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>> added, std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>> updated, std::vector<std::string> removed) const noexcept {
      _function->operator()(added, updated, removed);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_ create_Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string__Wrapper wrap_Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_(Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_ value) noexcept {
    return Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>
  /**
   * Specialized version of `std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>`.
   */
  using std__vector_std__shared_ptr_HybridARMeshAnchorSpec__ = std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>;
  inline std::vector<std::shared_ptr<HybridARMeshAnchorSpec>> create_std__vector_std__shared_ptr_HybridARMeshAnchorSpec__(size_t size) noexcept {
    std::vector<std::shared_ptr<HybridARMeshAnchorSpec>> vector;
    vector.reserve(size);
    return vector;
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>
  /**
   * Specialized version of `std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>&, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>&, const std::vector<std::string>&)>`.
   */
  using Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_ = std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>;
  /**
   * Wrapper class for a `std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& / * added * /, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& / * updated * /, const std::vector<std::string>& / * removed * /)>`, this can be used from Swift.
   */
  class Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string__Wrapper final {
  public:
    explicit Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string__Wrapper(std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>&& func): _function(std::make_unique<std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>>(std::move(func))) {}
    inline void call(std::vector<std::shared_ptr<HybridARMeshAnchorSpec>> added, std::vector<std::shared_ptr<HybridARMeshAnchorSpec>> updated, std::vector<std::string> removed) const noexcept {
      _function->operator()(added, updated, removed);
    }
  private:
    std::unique_ptr<std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_ create_Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string__Wrapper wrap_Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_(Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_ value) noexcept {
    return Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridARSessionSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARSessionSpec>`.
   */
  using std__shared_ptr_HybridARSessionSpec_ = std::shared_ptr<HybridARSessionSpec>;
  std::shared_ptr<HybridARSessionSpec> create_std__shared_ptr_HybridARSessionSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARSessionSpec_(std__shared_ptr_HybridARSessionSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARSessionSpec>
  using std__weak_ptr_HybridARSessionSpec_ = std::weak_ptr<HybridARSessionSpec>;
  inline std__weak_ptr_HybridARSessionSpec_ weakify_std__shared_ptr_HybridARSessionSpec_(const std::shared_ptr<HybridARSessionSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<CameraPose>
  using Result_CameraPose_ = Result<CameraPose>;
  inline Result_CameraPose_ create_Result_CameraPose_(const CameraPose& value) noexcept {
    return Result<CameraPose>::withValue(value);
  }
  inline Result_CameraPose_ create_Result_CameraPose_(const std::exception_ptr& error) noexcept {
    return Result<CameraPose>::withError(error);
  }
  
  // pragma MARK: Result<std::optional<std::shared_ptr<HybridARRaycastResultSpec>>>
  using Result_std__optional_std__shared_ptr_HybridARRaycastResultSpec___ = Result<std::optional<std::shared_ptr<HybridARRaycastResultSpec>>>;
  inline Result_std__optional_std__shared_ptr_HybridARRaycastResultSpec___ create_Result_std__optional_std__shared_ptr_HybridARRaycastResultSpec___(const std::optional<std::shared_ptr<HybridARRaycastResultSpec>>& value) noexcept {
    return Result<std::optional<std::shared_ptr<HybridARRaycastResultSpec>>>::withValue(value);
  }
  inline Result_std__optional_std__shared_ptr_HybridARRaycastResultSpec___ create_Result_std__optional_std__shared_ptr_HybridARRaycastResultSpec___(const std::exception_ptr& error) noexcept {
    return Result<std::optional<std::shared_ptr<HybridARRaycastResultSpec>>>::withError(error);
  }
  
  // pragma MARK: Result<std::vector<std::shared_ptr<HybridARRaycastResultSpec>>>
  using Result_std__vector_std__shared_ptr_HybridARRaycastResultSpec___ = Result<std::vector<std::shared_ptr<HybridARRaycastResultSpec>>>;
  inline Result_std__vector_std__shared_ptr_HybridARRaycastResultSpec___ create_Result_std__vector_std__shared_ptr_HybridARRaycastResultSpec___(const std::vector<std::shared_ptr<HybridARRaycastResultSpec>>& value) noexcept {
    return Result<std::vector<std::shared_ptr<HybridARRaycastResultSpec>>>::withValue(value);
  }
  inline Result_std__vector_std__shared_ptr_HybridARRaycastResultSpec___ create_Result_std__vector_std__shared_ptr_HybridARRaycastResultSpec___(const std::exception_ptr& error) noexcept {
    return Result<std::vector<std::shared_ptr<HybridARRaycastResultSpec>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<HybridARAnchorSpec>>
  using Result_std__shared_ptr_HybridARAnchorSpec__ = Result<std::shared_ptr<HybridARAnchorSpec>>;
  inline Result_std__shared_ptr_HybridARAnchorSpec__ create_Result_std__shared_ptr_HybridARAnchorSpec__(const std::shared_ptr<HybridARAnchorSpec>& value) noexcept {
    return Result<std::shared_ptr<HybridARAnchorSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_HybridARAnchorSpec__ create_Result_std__shared_ptr_HybridARAnchorSpec__(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<HybridARAnchorSpec>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<HybridARMeasurementSpec>>
  using Result_std__shared_ptr_HybridARMeasurementSpec__ = Result<std::shared_ptr<HybridARMeasurementSpec>>;
  inline Result_std__shared_ptr_HybridARMeasurementSpec__ create_Result_std__shared_ptr_HybridARMeasurementSpec__(const std::shared_ptr<HybridARMeasurementSpec>& value) noexcept {
    return Result<std::shared_ptr<HybridARMeasurementSpec>>::withValue(value);
  }
  inline Result_std__shared_ptr_HybridARMeasurementSpec__ create_Result_std__shared_ptr_HybridARMeasurementSpec__(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<HybridARMeasurementSpec>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>>
  using Result_std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec____ = Result<std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>>;
  inline Result_std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec____ create_Result_std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec____(const std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec____ create_Result_std__shared_ptr_Promise_std__shared_ptr_HybridARWorldMapSpec____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::shared_ptr<HybridARWorldMapSpec>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::function<void()>>
  using Result_std__function_void____ = Result<std::function<void()>>;
  inline Result_std__function_void____ create_Result_std__function_void____(const std::function<void()>& value) noexcept {
    return Result<std::function<void()>>::withValue(value);
  }
  inline Result_std__function_void____ create_Result_std__function_void____(const std::exception_ptr& error) noexcept {
    return Result<std::function<void()>>::withError(error);
  }
  
  // pragma MARK: Result<LiDARCapabilities>
  using Result_LiDARCapabilities_ = Result<LiDARCapabilities>;
  inline Result_LiDARCapabilities_ create_Result_LiDARCapabilities_(const LiDARCapabilities& value) noexcept {
    return Result<LiDARCapabilities>::withValue(value);
  }
  inline Result_LiDARCapabilities_ create_Result_LiDARCapabilities_(const std::exception_ptr& error) noexcept {
    return Result<LiDARCapabilities>::withError(error);
  }
  
  // pragma MARK: std::optional<ARViewHitResult>
  /**
   * Specialized version of `std::optional<ARViewHitResult>`.
   */
  using std__optional_ARViewHitResult_ = std::optional<ARViewHitResult>;
  inline std::optional<ARViewHitResult> create_std__optional_ARViewHitResult_(const ARViewHitResult& value) noexcept {
    return std::optional<ARViewHitResult>(value);
  }
  inline bool has_value_std__optional_ARViewHitResult_(const std::optional<ARViewHitResult>& optional) noexcept {
    return optional.has_value();
  }
  inline ARViewHitResult get_std__optional_ARViewHitResult_(const std::optional<ARViewHitResult>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>`.
   */
  using std__optional_std__shared_ptr_HybridARSegmentationResultSpec__ = std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>;
  inline std::optional<std::shared_ptr<HybridARSegmentationResultSpec>> create_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__(const std::shared_ptr<HybridARSegmentationResultSpec>& value) noexcept {
    return std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<HybridARSegmentationResultSpec> get_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>`.
   */
  using std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec____ = std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>;
  inline std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>> create_std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec____() noexcept {
    return Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>::create();
  }
  inline PromiseHolder<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>> wrap_std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec____(std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>> promise) noexcept {
    return PromiseHolder<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>&)>`.
   */
  using Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__ = std::function<void(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec___Wrapper final {
  public:
    explicit Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec___Wrapper(std::function<void(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<std::shared_ptr<HybridARSegmentationResultSpec>> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__ create_Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec___Wrapper wrap_Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__(Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec__ value) noexcept {
    return Func_void_std__optional_std__shared_ptr_HybridARSegmentationResultSpec___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>
  /**
   * Specialized version of `std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>`.
   */
  using std__shared_ptr_Promise_std__optional_ARObjectMeasurement___ = std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>;
  inline std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>> create_std__shared_ptr_Promise_std__optional_ARObjectMeasurement___() noexcept {
    return Promise<std::optional<ARObjectMeasurement>>::create();
  }
  inline PromiseHolder<std::optional<ARObjectMeasurement>> wrap_std__shared_ptr_Promise_std__optional_ARObjectMeasurement___(std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>> promise) noexcept {
    return PromiseHolder<std::optional<ARObjectMeasurement>>(std::move(promise));
  }
  
  // pragma MARK: std::function<void(const std::optional<ARObjectMeasurement>& /* result */)>
  /**
   * Specialized version of `std::function<void(const std::optional<ARObjectMeasurement>&)>`.
   */
  using Func_void_std__optional_ARObjectMeasurement_ = std::function<void(const std::optional<ARObjectMeasurement>& /* result */)>;
  /**
   * Wrapper class for a `std::function<void(const std::optional<ARObjectMeasurement>& / * result * /)>`, this can be used from Swift.
   */
  class Func_void_std__optional_ARObjectMeasurement__Wrapper final {
  public:
    explicit Func_void_std__optional_ARObjectMeasurement__Wrapper(std::function<void(const std::optional<ARObjectMeasurement>& /* result */)>&& func): _function(std::make_unique<std::function<void(const std::optional<ARObjectMeasurement>& /* result */)>>(std::move(func))) {}
    inline void call(std::optional<ARObjectMeasurement> result) const noexcept {
      _function->operator()(result);
    }
  private:
    std::unique_ptr<std::function<void(const std::optional<ARObjectMeasurement>& /* result */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__optional_ARObjectMeasurement_ create_Func_void_std__optional_ARObjectMeasurement_(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__optional_ARObjectMeasurement__Wrapper wrap_Func_void_std__optional_ARObjectMeasurement_(Func_void_std__optional_ARObjectMeasurement_ value) noexcept {
    return Func_void_std__optional_ARObjectMeasurement__Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridARViewSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridARViewSpec>`.
   */
  using std__shared_ptr_HybridARViewSpec_ = std::shared_ptr<HybridARViewSpec>;
  std::shared_ptr<HybridARViewSpec> create_std__shared_ptr_HybridARViewSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridARViewSpec_(std__shared_ptr_HybridARViewSpec_ cppType);
  
  // pragma MARK: std::weak_ptr<HybridARViewSpec>
  using std__weak_ptr_HybridARViewSpec_ = std::weak_ptr<HybridARViewSpec>;
  inline std__weak_ptr_HybridARViewSpec_ weakify_std__shared_ptr_HybridARViewSpec_(const std::shared_ptr<HybridARViewSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<std::optional<ARViewHitResult>>
  using Result_std__optional_ARViewHitResult__ = Result<std::optional<ARViewHitResult>>;
  inline Result_std__optional_ARViewHitResult__ create_Result_std__optional_ARViewHitResult__(const std::optional<ARViewHitResult>& value) noexcept {
    return Result<std::optional<ARViewHitResult>>::withValue(value);
  }
  inline Result_std__optional_ARViewHitResult__ create_Result_std__optional_ARViewHitResult__(const std::exception_ptr& error) noexcept {
    return Result<std::optional<ARViewHitResult>>::withError(error);
  }
  
  // pragma MARK: Result<bool>
  using Result_bool_ = Result<bool>;
  inline Result_bool_ create_Result_bool_(bool value) noexcept {
    return Result<bool>::withValue(std::move(value));
  }
  inline Result_bool_ create_Result_bool_(const std::exception_ptr& error) noexcept {
    return Result<bool>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>>
  using Result_std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec_____ = Result<std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec_____ create_Result_std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec_____(const std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec_____ create_Result_std__shared_ptr_Promise_std__optional_std__shared_ptr_HybridARSegmentationResultSpec_____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<std::shared_ptr<HybridARSegmentationResultSpec>>>>>::withError(error);
  }
  
  // pragma MARK: Result<std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>>
  using Result_std__shared_ptr_Promise_std__optional_ARObjectMeasurement____ = Result<std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>>;
  inline Result_std__shared_ptr_Promise_std__optional_ARObjectMeasurement____ create_Result_std__shared_ptr_Promise_std__optional_ARObjectMeasurement____(const std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>& value) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>>::withValue(value);
  }
  inline Result_std__shared_ptr_Promise_std__optional_ARObjectMeasurement____ create_Result_std__shared_ptr_Promise_std__optional_ARObjectMeasurement____(const std::exception_ptr& error) noexcept {
    return Result<std::shared_ptr<Promise<std::optional<ARObjectMeasurement>>>>::withError(error);
  }

} // namespace margelo::nitro::ar::bridge::swift
