///
/// NitroAR-Swift-Cxx-Bridge.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#include "NitroAR-Swift-Cxx-Bridge.hpp"

// Include C++ implementation defined types
#include "HybridARAnchorSpecSwift.hpp"
#include "HybridARBoundingBoxBuilderSpecSwift.hpp"
#include "HybridARDepthDataSpecSwift.hpp"
#include "HybridARDirectionalLightEstimateSpecSwift.hpp"
#include "HybridARFrameSpecSwift.hpp"
#include "HybridARLightEstimateSpecSwift.hpp"
#include "HybridARMeasurementSpecSwift.hpp"
#include "HybridARMeshAnchorSpecSwift.hpp"
#include "HybridARPlaneAnchorSpecSwift.hpp"
#include "HybridARPlaneGeometrySpecSwift.hpp"
#include "HybridARRaycastResultSpecSwift.hpp"
#include "HybridARSessionSpecSwift.hpp"
#include "HybridARViewSpecSwift.hpp"
#include "HybridARVolumeSpecSwift.hpp"
#include "HybridARWorldMapSpecSwift.hpp"
#include "NitroAR-Swift-Cxx-Umbrella.hpp"
#include <NitroModules/NitroDefines.hpp>

namespace margelo::nitro::ar::bridge::swift {

  // pragma MARK: std::shared_ptr<HybridARAnchorSpec>
  std::shared_ptr<HybridARAnchorSpec> create_std__shared_ptr_HybridARAnchorSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARAnchorSpec_cxx swiftPart = NitroAR::HybridARAnchorSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARAnchorSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARAnchorSpec_(std__shared_ptr_HybridARAnchorSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARAnchorSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARAnchorSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARAnchorSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARAnchorSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARVolumeSpec>
  std::shared_ptr<HybridARVolumeSpec> create_std__shared_ptr_HybridARVolumeSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARVolumeSpec_cxx swiftPart = NitroAR::HybridARVolumeSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARVolumeSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARVolumeSpec_(std__shared_ptr_HybridARVolumeSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARVolumeSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARVolumeSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARVolumeSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARVolumeSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARBoundingBoxBuilderSpec>
  std::shared_ptr<HybridARBoundingBoxBuilderSpec> create_std__shared_ptr_HybridARBoundingBoxBuilderSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARBoundingBoxBuilderSpec_cxx swiftPart = NitroAR::HybridARBoundingBoxBuilderSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARBoundingBoxBuilderSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARBoundingBoxBuilderSpec_(std__shared_ptr_HybridARBoundingBoxBuilderSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARBoundingBoxBuilderSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARBoundingBoxBuilderSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARBoundingBoxBuilderSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARBoundingBoxBuilderSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARDepthDataSpec>
  std::shared_ptr<HybridARDepthDataSpec> create_std__shared_ptr_HybridARDepthDataSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARDepthDataSpec_cxx swiftPart = NitroAR::HybridARDepthDataSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARDepthDataSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARDepthDataSpec_(std__shared_ptr_HybridARDepthDataSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARDepthDataSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARDepthDataSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARDepthDataSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARDepthDataSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARLightEstimateSpec>
  std::shared_ptr<HybridARLightEstimateSpec> create_std__shared_ptr_HybridARLightEstimateSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARLightEstimateSpec_cxx swiftPart = NitroAR::HybridARLightEstimateSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARLightEstimateSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARLightEstimateSpec_(std__shared_ptr_HybridARLightEstimateSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARLightEstimateSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARLightEstimateSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARLightEstimateSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARLightEstimateSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARDirectionalLightEstimateSpec>
  std::shared_ptr<HybridARDirectionalLightEstimateSpec> create_std__shared_ptr_HybridARDirectionalLightEstimateSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARDirectionalLightEstimateSpec_cxx swiftPart = NitroAR::HybridARDirectionalLightEstimateSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARDirectionalLightEstimateSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARDirectionalLightEstimateSpec_(std__shared_ptr_HybridARDirectionalLightEstimateSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARDirectionalLightEstimateSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARDirectionalLightEstimateSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARDirectionalLightEstimateSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARDirectionalLightEstimateSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARFrameSpec>
  std::shared_ptr<HybridARFrameSpec> create_std__shared_ptr_HybridARFrameSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARFrameSpec_cxx swiftPart = NitroAR::HybridARFrameSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARFrameSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARFrameSpec_(std__shared_ptr_HybridARFrameSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARFrameSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARFrameSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARFrameSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARFrameSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARMeasurementSpec>
  std::shared_ptr<HybridARMeasurementSpec> create_std__shared_ptr_HybridARMeasurementSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARMeasurementSpec_cxx swiftPart = NitroAR::HybridARMeasurementSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARMeasurementSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARMeasurementSpec_(std__shared_ptr_HybridARMeasurementSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARMeasurementSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARMeasurementSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARMeasurementSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARMeasurementSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARPlaneGeometrySpec>
  std::shared_ptr<HybridARPlaneGeometrySpec> create_std__shared_ptr_HybridARPlaneGeometrySpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARPlaneGeometrySpec_cxx swiftPart = NitroAR::HybridARPlaneGeometrySpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARPlaneGeometrySpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARPlaneGeometrySpec_(std__shared_ptr_HybridARPlaneGeometrySpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARPlaneGeometrySpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARPlaneGeometrySpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARPlaneGeometrySpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARPlaneGeometrySpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARPlaneAnchorSpec>
  std::shared_ptr<HybridARPlaneAnchorSpec> create_std__shared_ptr_HybridARPlaneAnchorSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARPlaneAnchorSpec_cxx swiftPart = NitroAR::HybridARPlaneAnchorSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARPlaneAnchorSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARPlaneAnchorSpec_(std__shared_ptr_HybridARPlaneAnchorSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARPlaneAnchorSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARPlaneAnchorSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARPlaneAnchorSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARPlaneAnchorSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARRaycastResultSpec>
  std::shared_ptr<HybridARRaycastResultSpec> create_std__shared_ptr_HybridARRaycastResultSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARRaycastResultSpec_cxx swiftPart = NitroAR::HybridARRaycastResultSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARRaycastResultSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARRaycastResultSpec_(std__shared_ptr_HybridARRaycastResultSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARRaycastResultSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARRaycastResultSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARRaycastResultSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARRaycastResultSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARMeshAnchorSpec>
  std::shared_ptr<HybridARMeshAnchorSpec> create_std__shared_ptr_HybridARMeshAnchorSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARMeshAnchorSpec_cxx swiftPart = NitroAR::HybridARMeshAnchorSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARMeshAnchorSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARMeshAnchorSpec_(std__shared_ptr_HybridARMeshAnchorSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARMeshAnchorSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARMeshAnchorSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARMeshAnchorSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARMeshAnchorSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARWorldMapSpec>
  std::shared_ptr<HybridARWorldMapSpec> create_std__shared_ptr_HybridARWorldMapSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARWorldMapSpec_cxx swiftPart = NitroAR::HybridARWorldMapSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARWorldMapSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARWorldMapSpec_(std__shared_ptr_HybridARWorldMapSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARWorldMapSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARWorldMapSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARWorldMapSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARWorldMapSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::function<void(const std::shared_ptr<HybridARWorldMapSpec>& /* result */)>
  Func_void_std__shared_ptr_HybridARWorldMapSpec_ create_Func_void_std__shared_ptr_HybridARWorldMapSpec_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void_std__shared_ptr_HybridARWorldMapSpec_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::shared_ptr<HybridARWorldMapSpec>& result) mutable -> void {
      swiftClosure.call(result);
    };
  }
  
  // pragma MARK: std::function<void(const std::exception_ptr& /* error */)>
  Func_void_std__exception_ptr create_Func_void_std__exception_ptr(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void_std__exception_ptr::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::exception_ptr& error) mutable -> void {
      swiftClosure.call(error);
    };
  }
  
  // pragma MARK: std::function<void()>
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)]() mutable -> void {
      swiftClosure.call();
    };
  }
  
  // pragma MARK: std::function<void(const std::shared_ptr<HybridARFrameSpec>& /* frame */)>
  Func_void_std__shared_ptr_HybridARFrameSpec_ create_Func_void_std__shared_ptr_HybridARFrameSpec_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void_std__shared_ptr_HybridARFrameSpec_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::shared_ptr<HybridARFrameSpec>& frame) mutable -> void {
      swiftClosure.call(frame);
    };
  }
  
  // pragma MARK: std::function<void(TrackingState /* state */, TrackingStateReason /* reason */)>
  Func_void_TrackingState_TrackingStateReason create_Func_void_TrackingState_TrackingStateReason(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void_TrackingState_TrackingStateReason::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](TrackingState state, TrackingStateReason reason) mutable -> void {
      swiftClosure.call(static_cast<int>(state), static_cast<int>(reason));
    };
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>
  Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_ create_Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void_std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__shared_ptr_HybridARAnchorSpec___std__vector_std__string_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<std::shared_ptr<HybridARAnchorSpec>>& added, const std::vector<std::shared_ptr<HybridARAnchorSpec>>& updated, const std::vector<std::string>& removed) mutable -> void {
      swiftClosure.call(added, updated, removed);
    };
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>
  Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_ create_Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void_std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__shared_ptr_HybridARPlaneAnchorSpec___std__vector_std__string_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& added, const std::vector<std::shared_ptr<HybridARPlaneAnchorSpec>>& updated, const std::vector<std::string>& removed) mutable -> void {
      swiftClosure.call(added, updated, removed);
    };
  }
  
  // pragma MARK: std::function<void(const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* added */, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& /* updated */, const std::vector<std::string>& /* removed */)>
  Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_ create_Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_(void* NON_NULL swiftClosureWrapper) noexcept {
    auto swiftClosure = NitroAR::Func_void_std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__shared_ptr_HybridARMeshAnchorSpec___std__vector_std__string_::fromUnsafe(swiftClosureWrapper);
    return [swiftClosure = std::move(swiftClosure)](const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& added, const std::vector<std::shared_ptr<HybridARMeshAnchorSpec>>& updated, const std::vector<std::string>& removed) mutable -> void {
      swiftClosure.call(added, updated, removed);
    };
  }
  
  // pragma MARK: std::shared_ptr<HybridARSessionSpec>
  std::shared_ptr<HybridARSessionSpec> create_std__shared_ptr_HybridARSessionSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARSessionSpec_cxx swiftPart = NitroAR::HybridARSessionSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARSessionSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARSessionSpec_(std__shared_ptr_HybridARSessionSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARSessionSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARSessionSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARSessionSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARSessionSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }
  
  // pragma MARK: std::shared_ptr<HybridARViewSpec>
  std::shared_ptr<HybridARViewSpec> create_std__shared_ptr_HybridARViewSpec_(void* NON_NULL swiftUnsafePointer) noexcept {
    NitroAR::HybridARViewSpec_cxx swiftPart = NitroAR::HybridARViewSpec_cxx::fromUnsafe(swiftUnsafePointer);
    return std::make_shared<margelo::nitro::ar::HybridARViewSpecSwift>(swiftPart);
  }
  void* NON_NULL get_std__shared_ptr_HybridARViewSpec_(std__shared_ptr_HybridARViewSpec_ cppType) {
    std::shared_ptr<margelo::nitro::ar::HybridARViewSpecSwift> swiftWrapper = std::dynamic_pointer_cast<margelo::nitro::ar::HybridARViewSpecSwift>(cppType);
    #ifdef NITRO_DEBUG
    if (swiftWrapper == nullptr) [[unlikely]] {
      throw std::runtime_error("Class \"HybridARViewSpec\" is not implemented in Swift!");
    }
    #endif
    NitroAR::HybridARViewSpec_cxx& swiftPart = swiftWrapper->getSwiftPart();
    return swiftPart.toUnsafe();
  }

} // namespace margelo::nitro::ar::bridge::swift
