///
/// HybridARViewComponent.mm
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#import "HybridARViewComponent.hpp"
#import <memory>
#import <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#import <React/RCTViewComponentView.h>
#import <React/RCTComponentViewFactory.h>
#import <React/UIView+ComponentViewProtocol.h>
#import <NitroModules/NitroDefines.hpp>
#import <UIKit/UIKit.h>

#import "HybridARViewSpecSwift.hpp"
#import "NitroAR-Swift-Cxx-Umbrella.hpp"

using namespace facebook;
using namespace margelo::nitro::ar;
using namespace margelo::nitro::ar::views;

/**
 * Represents the React Native View holder for the Nitro "ARView" HybridView.
 */
@interface HybridARViewComponent: RCTViewComponentView
+ (BOOL)shouldBeRecycled;
@end

@implementation HybridARViewComponent {
  std::shared_ptr<HybridARViewSpecSwift> _hybridView;
}

+ (void) load {
  [super load];
  [RCTComponentViewFactory.currentComponentViewFactory registerComponentViewClass:[HybridARViewComponent class]];
}

+ (react::ComponentDescriptorProvider) componentDescriptorProvider {
  return react::concreteComponentDescriptorProvider<HybridARViewComponentDescriptor>();
}

- (instancetype) init {
  if (self = [super init]) {
    std::shared_ptr<HybridARViewSpec> hybridView = NitroAR::NitroARAutolinking::createARView();
    _hybridView = std::dynamic_pointer_cast<HybridARViewSpecSwift>(hybridView);
    [self updateView];
  }
  return self;
}

- (void) updateView {
  // 1. Get Swift part
  NitroAR::HybridARViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Get UIView*
  void* viewUnsafe = swiftPart.getView();
  UIView* view = (__bridge_transfer UIView*) viewUnsafe;

  // 3. Update RCTViewComponentView's [contentView]
  [self setContentView:view];
}

- (void) updateProps:(const std::shared_ptr<const react::Props>&)props
            oldProps:(const std::shared_ptr<const react::Props>&)oldProps {
  // 1. Downcast props
  const auto& newViewPropsConst = *std::static_pointer_cast<HybridARViewProps const>(props);
  auto& newViewProps = const_cast<HybridARViewProps&>(newViewPropsConst);
  NitroAR::HybridARViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Update each prop individually
  swiftPart.beforeUpdate();

  // showDebugOptions: optional
  if (newViewProps.showDebugOptions.isDirty) {
    swiftPart.setShowDebugOptions(newViewProps.showDebugOptions.value);
    newViewProps.showDebugOptions.isDirty = false;
  }
  // showPlanes: optional
  if (newViewProps.showPlanes.isDirty) {
    swiftPart.setShowPlanes(newViewProps.showPlanes.value);
    newViewProps.showPlanes.isDirty = false;
  }
  // showFeaturePoints: optional
  if (newViewProps.showFeaturePoints.isDirty) {
    swiftPart.setShowFeaturePoints(newViewProps.showFeaturePoints.value);
    newViewProps.showFeaturePoints.isDirty = false;
  }
  // showWorldOrigin: optional
  if (newViewProps.showWorldOrigin.isDirty) {
    swiftPart.setShowWorldOrigin(newViewProps.showWorldOrigin.value);
    newViewProps.showWorldOrigin.isDirty = false;
  }
  // autoenablesDefaultLighting: optional
  if (newViewProps.autoenablesDefaultLighting.isDirty) {
    swiftPart.setAutoenablesDefaultLighting(newViewProps.autoenablesDefaultLighting.value);
    newViewProps.autoenablesDefaultLighting.isDirty = false;
  }
  // sceneReconstruction: optional
  if (newViewProps.sceneReconstruction.isDirty) {
    swiftPart.setSceneReconstruction(newViewProps.sceneReconstruction.value);
    newViewProps.sceneReconstruction.isDirty = false;
  }
  // showSceneMesh: optional
  if (newViewProps.showSceneMesh.isDirty) {
    swiftPart.setShowSceneMesh(newViewProps.showSceneMesh.value);
    newViewProps.showSceneMesh.isDirty = false;
  }
  // sceneDepth: optional
  if (newViewProps.sceneDepth.isDirty) {
    swiftPart.setSceneDepth(newViewProps.sceneDepth.value);
    newViewProps.sceneDepth.isDirty = false;
  }
  // objectOcclusion: optional
  if (newViewProps.objectOcclusion.isDirty) {
    swiftPart.setObjectOcclusion(newViewProps.objectOcclusion.value);
    newViewProps.objectOcclusion.isDirty = false;
  }
  // peopleOcclusion: optional
  if (newViewProps.peopleOcclusion.isDirty) {
    swiftPart.setPeopleOcclusion(newViewProps.peopleOcclusion.value);
    newViewProps.peopleOcclusion.isDirty = false;
  }

  swiftPart.afterUpdate();

  // 3. Update hybridRef if it changed
  if (newViewProps.hybridRef.isDirty) {
    // hybridRef changed - call it with new this
    const auto& maybeFunc = newViewProps.hybridRef.value;
    if (maybeFunc.has_value()) {
      maybeFunc.value()(_hybridView);
    }
    newViewProps.hybridRef.isDirty = false;
  }

  // 4. Continue in base class
  [super updateProps:props oldProps:oldProps];
}

+ (BOOL)shouldBeRecycled {
  return NitroAR::NitroARAutolinking::isARViewRecyclable();
}

- (void)prepareForRecycle {
  [super prepareForRecycle];
  NitroAR::HybridARViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();
  swiftPart.maybePrepareForRecycle();
}

@end
