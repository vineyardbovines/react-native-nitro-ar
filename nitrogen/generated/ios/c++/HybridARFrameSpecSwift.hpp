///
/// HybridARFrameSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#pragma once

#include "HybridARFrameSpec.hpp"

// Forward declaration of `HybridARFrameSpec_cxx` to properly resolve imports.
namespace NitroAR { class HybridARFrameSpec_cxx; }

// Forward declaration of `HybridARLightEstimateSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARLightEstimateSpec; }
// Forward declaration of `HybridARDirectionalLightEstimateSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARDirectionalLightEstimateSpec; }
// Forward declaration of `HybridARDepthDataSpec` to properly resolve imports.
namespace margelo::nitro::ar { class HybridARDepthDataSpec; }

#include <vector>
#include <memory>
#include "HybridARLightEstimateSpec.hpp"
#include <optional>
#include "HybridARDirectionalLightEstimateSpec.hpp"
#include "HybridARDepthDataSpec.hpp"
#include <string>

#include "NitroAR-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::ar {

  /**
   * The C++ part of HybridARFrameSpec_cxx.swift.
   *
   * HybridARFrameSpecSwift (C++) accesses HybridARFrameSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridARFrameSpec_cxx can directly inherit from the C++ class HybridARFrameSpec
   * to simplify the whole structure and memory management.
   */
  class HybridARFrameSpecSwift: public virtual HybridARFrameSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridARFrameSpecSwift(const NitroAR::HybridARFrameSpec_cxx& swiftPart):
      HybridObject(HybridARFrameSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline NitroAR::HybridARFrameSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    bool equals(const std::shared_ptr<HybridObject>& other) override {
      if (auto otherCast = std::dynamic_pointer_cast<HybridARFrameSpecSwift>(other)) {
        return _swiftPart.equals(otherCast->_swiftPart);
      }
      return false;
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }
    std::string toString() override {
      return _swiftPart.toString();
    }

  public:
    // Properties
    inline double getTimestamp() noexcept override {
      return _swiftPart.getTimestamp();
    }
    inline std::vector<double> getCameraPosition() noexcept override {
      auto __result = _swiftPart.getCameraPosition();
      return __result;
    }
    inline std::vector<double> getCameraRotation() noexcept override {
      auto __result = _swiftPart.getCameraRotation();
      return __result;
    }
    inline std::vector<double> getProjectionMatrix() noexcept override {
      auto __result = _swiftPart.getProjectionMatrix();
      return __result;
    }
    inline std::vector<double> getViewMatrix() noexcept override {
      auto __result = _swiftPart.getViewMatrix();
      return __result;
    }
    inline std::vector<double> getCameraIntrinsics() noexcept override {
      auto __result = _swiftPart.getCameraIntrinsics();
      return __result;
    }
    inline std::vector<double> getImageResolution() noexcept override {
      auto __result = _swiftPart.getImageResolution();
      return __result;
    }
    inline std::optional<std::shared_ptr<HybridARLightEstimateSpec>> getLightEstimate() noexcept override {
      auto __result = _swiftPart.getLightEstimate();
      return __result;
    }
    inline std::optional<std::shared_ptr<HybridARDirectionalLightEstimateSpec>> getDirectionalLightEstimate() noexcept override {
      auto __result = _swiftPart.getDirectionalLightEstimate();
      return __result;
    }
    inline std::optional<std::shared_ptr<HybridARDepthDataSpec>> getSceneDepth() noexcept override {
      auto __result = _swiftPart.getSceneDepth();
      return __result;
    }
    inline std::optional<std::shared_ptr<HybridARDepthDataSpec>> getSmoothedSceneDepth() noexcept override {
      auto __result = _swiftPart.getSmoothedSceneDepth();
      return __result;
    }

  public:
    // Methods
    inline std::string getCapturedImage(double quality) override {
      auto __result = _swiftPart.getCapturedImage(std::forward<decltype(quality)>(quality));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }

  private:
    NitroAR::HybridARFrameSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::ar
